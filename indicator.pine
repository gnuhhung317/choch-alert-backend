//@version=5
indicator("Pivot Waves + 8-Pattern + CHoCH (upfate ver.)", overlay=true, max_lines_count=500, max_labels_count=500)

// ========== Inputs ==========
left        = input.int(1,  "Pivot Left",  minval=1)
right       = input.int(1,  "Pivot Right", minval=1)
drawWaves   = input.bool(true, "Vẽ sóng (nối line giữa các pivot)")
useBodyBreak= input.bool(true, "CHoCH theo thân nến (close)")
touchTicks  = input.int(2, "Độ dung sai 'chạm' (số tick)", minval=0)
keepPivots  = input.int(200, "Số pivot tối đa lưu", minval=20)
plotPvtMark = input.bool(true, "Hiển thị PH/PL")
plotEightLbl = input.bool(true, "Ghi nhãn P1..P8 gần nhất")
showTable   = input.bool(true, "Bảng thông tin")

// --- Variant filters (BẮT BUỘC - chỉ detect pivot có variant hợp lệ)
allowPH1 = input.bool(true,  "Cho phép PH loại 1")
allowPH2 = input.bool(true,  "Cho phép PH loại 2 (con là nến #1)")
allowPH3 = input.bool(true,  "Cho phép PH loại 3 (biến thể khác)")
allowPL1 = input.bool(true,  "Cho phép PL loại 1")
allowPL2 = input.bool(true,  "Cho phép PL loại 2 (con là nến #1)")
allowPL3 = input.bool(true,  "Cho phép PL loại 3 (biến thể khác)")
showVariantLabel = input.bool(false, "Hiển thị mã biến thể trên chart")

var bool chochLocked = false 

// Store CHoCH bar for persistent label
var int chochUpBar = na
var int chochDownBar = na 

// ========== Storage ==========
var prices = array.new_float()
var bars   = array.new_int()
var highs  = array.new_bool()
var volumes = array.new_float()  // Store pivot volumes

storePivot(_bar, _price, _isHigh) =>
    array.push(bars,   _bar)
    array.push(prices, _price)
    array.push(highs,  _isHigh)
    // Store volume at pivot bar
    off = math.max(0, bar_index - _bar)
    array.push(volumes, volume[off])
    while array.size(bars) > keepPivots
        array.shift(bars)
        array.shift(prices)
        array.shift(highs)
        array.shift(volumes)

pCount() => array.size(prices)

getPivotFromEnd(idxFromEnd) =>
    sz = array.size(prices)
    [ array.get(bars,   sz-1-idxFromEnd),
      array.get(prices, sz-1-idxFromEnd),
      array.get(highs,  sz-1-idxFromEnd) ]

getVolumeFromEnd(idxFromEnd) =>
    sz = array.size(volumes)
    array.get(volumes, sz-1-idxFromEnd)

// Dung sai tick
tol = syminfo.mintick * touchTicks

// ========== Helpers cho phân loại biến thể ==========
getHLTripletAroundMid() =>
    // Timeline: [LEFT/h3] → [CENTER/h2/PIVOT] → [RIGHT/h1]
    // Pine indexing: [right+1] → [right] → [right-1]
    float h2 = high[right]      // CENTER (pivot bar)
    float l2 = low[right]
    float h3 = na               // LEFT side
    float l3 = na
    float h1 = na               // RIGHT side
    float l1 = na
    
    if bar_index > right + 1
        h3 := high[right + 1]   // LEFT side
        l3 := low[right + 1]
    if right - 1 >= 0
        h1 := high[right - 1]   // RIGHT side
        l1 := low[right - 1]
    [h1,h2,h3,l1,l2,l3]

isPH_type1() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (h2 > h1 and h2 > h3) and (l2 > l1 and l2 > l3)

isPH_type2() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (h2 >= h1 and h2 > h3) and (l2 > l3 and l2 < l1)

isPH_type3() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (h2 > h1 and h2 >= h3) and (l2 < l3 and l2 > l1)

isPL_type1() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (l2 < l1 and l2 < l3) and (h2 < h1 and h2 < h3)

isPL_type2() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (h2 >= h1 and h2 < h3) and (l2 < l3 and l2 <= l1)

isPL_type3() =>
    [h1,h2,h3,l1,l2,l3] = getHLTripletAroundMid()
    not na(h1) and not na(h3) and (l2 < l1 and l2 < l3) and (h2 < h1 and h2 > h3)

classifyPivotVariant(isHighPivot) =>
    var string t = "NA"
    if isHighPivot
        t := isPH_type1() ? "PH1" :
             isPH_type2() ? "PH2" :
             isPH_type3() ? "PH3" : "NA"
    else
        t := isPL_type1() ? "PL1" :
             isPL_type2() ? "PL2" :
             isPL_type3() ? "PL3" : "NA"
    t

allowedByUser(t) =>
    switch t
        "PH1" => allowPH1
        "PH2" => allowPH2
        "PH3" => allowPH3
        "PL1" => allowPL1
        "PL2" => allowPL2
        "PL3" => allowPL3
        => false

// ========== Custom Pivot Detection (không dùng ta.pivot*) ==========
// Detect pivot manually based on variant classification only
var bool isPH = false
var bool isPL = false
var float newPivotPrice = na
var int newPivotBar = na
var bool newPivotHigh = false

// Reset detection flags
isPH := false
isPL := false
newPivotPrice := na
newPivotBar := na

// Chỉ check khi có đủ bars 2 bên
if bar_index > right + 1 and right - 1 >= 0
    // Check Pivot High variants
    if isPH_type1() and allowPH1
        isPH := true
    else if isPH_type2() and allowPH2
        isPH := true
    else if isPH_type3() and allowPH3
        isPH := true
    
    // Check Pivot Low variants
    if isPL_type1() and allowPL1
        isPL := true
    else if isPL_type2() and allowPL2
        isPL := true
    else if isPL_type3() and allowPL3
        isPL := true
    
    // Set pivot data if detected
    if isPH
        newPivotPrice := high[right]
        newPivotBar := bar_index - right
        newPivotHigh := true
    else if isPL
        newPivotPrice := low[right]
        newPivotBar := bar_index - right
        newPivotHigh := false

// ========== State vars ==========
var int   lastPivotBar   = na
var float lastPivotPrice = na
var bool  lastEightUp    = false
var bool  lastEightDown  = false
var int   lastEightBarIdx = na
var float p2_price       = na
var bool  acceptedPH_event = false
var bool  acceptedPL_event = false

// Pattern group order flags (needed for CHoCH confirmation)
var bool g1_upOrder = false
var bool g1_downOrder = false
var bool g2_upOrder = false
var bool g2_downOrder = false
var bool g3_upOrder = false
var bool g3_downOrder = false
// Additional groups G4, G5, G6 (and mirrors) requested
var bool g4_upOrder = false
var bool g4_downOrder = false
var bool g5_upOrder = false
var bool g5_downOrder = false
var bool g6_upOrder = false
var bool g6_downOrder = false

// ========== Khi có pivot mới ==========
acceptedPH_event := false
acceptedPL_event := false

if (isPH or isPL)
    // ========== BẮT BUỘC lọc theo variant - KHÔNG detect pivot thuần ==========
    tvar = classifyPivotVariant(isPH)
    accept = (tvar != "NA") and allowedByUser(tvar)

    if accept
        // --- chèn pivot giả nếu 2 pivot liên tiếp cùng loại (giữ nguyên cơ chế của bạn) ---
        if pCount() > 0
            [lastBar, lastPrice, lastHigh] = getPivotFromEnd(0)
            newHigh = isPH
            if lastHigh == newHigh
                gap = newPivotBar - lastBar - 1
                if gap > 0
                    firstBarInGap = lastBar + 1
                    lastBarInGap  = newPivotBar - 1
                    offsetFirst   = bar_index - firstBarInGap
                    offsetLast    = bar_index - lastBarInGap
                    if offsetFirst >= 0 and offsetLast >= 0
                        float insertPrice = newHigh ? low[offsetFirst] : high[offsetFirst]
                        int   insertBar   = firstBarInGap
                        bool  insertHigh  = not newHigh
                        for i = offsetFirst to offsetLast
                            float candidate = newHigh ? low[i] : high[i]
                            if (newHigh and candidate < insertPrice) or (not newHigh and candidate > insertPrice)
                                insertPrice := candidate
                                insertBar   := bar_index - i
                        if insertBar > lastBar and insertBar < newPivotBar
                            storePivot(insertBar, insertPrice, insertHigh)
                            if drawWaves and not na(lastPivotBar)
                                line.new(lastPivotBar, lastPivotPrice, insertBar, insertPrice, color=color.new(color.blue, 0), width=2)
                            lastPivotBar   := insertBar
                            lastPivotPrice := insertPrice

        // Lưu pivot mới
        storePivot(newPivotBar, newPivotPrice, newPivotHigh)
        if drawWaves and not na(lastPivotBar)
            line.new(lastPivotBar, lastPivotPrice, newPivotBar, newPivotPrice, color=color.new(color.blue, 0), width=2)
        lastPivotBar   := newPivotBar
        lastPivotPrice := newPivotPrice

        // reset khóa CHoCH khi đã hình thành pivot sau cụm 8 trước đó
        if not na(lastEightBarIdx) and newPivotBar > lastEightBarIdx
            chochLocked := false

        acceptedPH_event := isPH
        acceptedPL_event := isPL

        if showVariantLabel and tvar != "NA"
            label.new(newPivotBar, newPivotPrice, tvar, style=label.style_label_center,
                      textcolor=color.white, color=color.new(color.black, 10), size=size.tiny)

// ========== 8-Pattern ==========
var float pivot6 = na   // p6 (reference cho CHoCH)
var float pivot5 = na   // p5 (additional reference cho CHoCH)
var float saved_p5 = na // Store p5 for pattern group confirmation
var float saved_p7 = na // Store p7 for pattern group confirmation (G2)
var float saved_p8 = na // Store p8 for pattern group confirmation (G4/G5)
eightReady = pCount() >= 8
if eightReady
    [b8,p8,h8] = getPivotFromEnd(0)
    [b7,p7,h7] = getPivotFromEnd(1)
    [b6,p6,h6] = getPivotFromEnd(2)
    [b5,p5,h5] = getPivotFromEnd(3)
    [b4,p4,h4] = getPivotFromEnd(4)
    [b3,p3,h3] = getPivotFromEnd(5)
    [b2,p2,h2] = getPivotFromEnd(6)
    [b1,p1,h1] = getPivotFromEnd(7)

    // cấu trúc xen kẽ 8 pivot
    upStruct   = (not h1) and h2 and (not h3) and h4 and (not h5) and h6 and (not h7) and h8
    downStruct = h1 and (not h2) and h3 and (not h4) and h5 and (not h6) and h7 and (not h8)

    // Retest P7 ↔ P4 (thay vì P5 ↔ P2)
    off7 = math.max(0, bar_index - b7)
    off4 = math.max(0, bar_index - b4)
    hi7 = high[off7]
    lo7 = low[off7]
    hi4 = high[off4]
    lo4 = low[off4]
    touchRetest = (upStruct and (lo7 < hi4)) or (downStruct and (hi7 > lo4))

    // P8 là cực trị trong cụm 1–8
    highsArr  = array.from(p1, p2, p3, p4, p5, p6, p7, p8)
    lowsArr   = array.from(p1, p2, p3, p4, p5, p6, p7, p8)
    isHighest8 = p8 == array.max(highsArr)
    isLowest8  = p8 == array.min(lowsArr)

    // Ràng buộc thứ tự 8-pivot - 3 nhóm (G1, G2, G3)
    // Ràng buộc thứ tự - nhóm (G1..G6)
    // Note: some new groups (G4/G5) require 10 pivots. If we have >=10 pivots, compute p1..p10
    tenReady = pCount() >= 10
    
    // Declare pivot variables (non-var, local to this block)
    int b10 = na, int b9 = na
    float p10 = na, float p9 = na
    bool h10 = na, bool h9 = na
    
    if tenReady
        [b10,p10,h10] = getPivotFromEnd(0)
        [b9,p9,h9]   = getPivotFromEnd(1)
        [b8,p8,h8]   = getPivotFromEnd(2)
        [b7,p7,h7]   = getPivotFromEnd(3)
        [b6,p6,h6]   = getPivotFromEnd(4)
        [b5,p5,h5]   = getPivotFromEnd(5)
        [b4,p4,h4]   = getPivotFromEnd(6)
        [b3,p3,h3]   = getPivotFromEnd(7)
        [b2,p2,h2]   = getPivotFromEnd(8)
        [b1,p1,h1]   = getPivotFromEnd(9)
    else
        // Fallback to original 8-pivot mapping (p1..p8)
        [b8,p8,h8] = getPivotFromEnd(0)
        [b7,p7,h7] = getPivotFromEnd(1)
        [b6,p6,h6] = getPivotFromEnd(2)
        [b5,p5,h5] = getPivotFromEnd(3)
        [b4,p4,h4] = getPivotFromEnd(4)
        [b3,p3,h3] = getPivotFromEnd(5)
        [b2,p2,h2] = getPivotFromEnd(6)
        [b1,p1,h1] = getPivotFromEnd(7)
        // p9 and p10 remain na (already initialized above)

    // G1 (Original):
    g1_upOrder   := (p2 < p4 and p4 < p6 and p6 < p8) and (p3 < p5 and p5 < p7)
    g1_downOrder := (p3 > p5 and p5 > p7) and (p2 > p4 and p4 > p6 and p6 > p8)

    // G2:
    // Uptrend: p3 < p7 < p5, p2 < p6 < p4 < p8, p2 < p5
    g2_upOrder   := (p3 < p7 and p7 < p5) and (p2 < p6 and p6 < p4 and p4 < p8) and (p2 < p5)
    // Downtrend: p3 > p7 > p5, p2 > p6 > p4 > p8, p2 > p5
    g2_downOrder := (p3 > p7 and p7 > p5) and (p2 > p6 and p6 > p4 and p4 > p8) and (p2 > p5)

    // G3:
    // Uptrend: p3 < p5 < p7, p2 < p6 < p4 < p8, p2 < p5
    g3_upOrder   := (p3 < p5 and p5 < p7) and (p2 < p6 and p6 < p4 and p4 < p8) and (p2 < p5)
    // Downtrend: p3 > p5 > p7, p2 > p6 > p4 > p8, p2 > p5
    g3_downOrder := (p3 > p5 and p5 > p7) and (p2 > p6 and p6 > p4 and p4 > p8) and (p2 > p5)

    // G4 (requires 10 pivots):
    // Uptrend variant: p1 < p3 < p5 < p7 < p9, p2 < p8 < p4 < p6 < p10
    g4_upOrder := tenReady and (p1 < p3 and p3 < p5 and p5 < p7 and p7 < p9) and (p2 < p8 and p8 < p4 and p4 < p6 and p6 < p10)
    // Downtrend mirror: reverse inequalities
    g4_downOrder := tenReady and (p1 > p3 and p3 > p5 and p5 > p7 and p7 > p9) and (p2 > p8 and p8 > p4 and p4 > p6 and p6 > p10)

    // G5 (requires 10 pivots):
    // Uptrend: p1 < p3 < p5 < p9 < p7, p2 < p8 < p4 < p6 < p10
    g5_upOrder := tenReady and (p1 < p3 and p3 < p5 and p5 < p9 and p9 < p7) and (p2 < p8 and p8 < p4 and p4 < p6 and p6 < p10)
    // Downtrend mirror
    g5_downOrder := tenReady and (p1 > p3 and p3 > p5 and p5 > p9 and p9 > p7) and (p2 > p8 and p8 > p4 and p4 > p6 and p6 > p10)

    // G6 (uses up to p8):
    // Uptrend: p1 < p3 < p5 < p7, p2 < p4 < p6 < p8, p5 < p2, p7 < p4
    g6_upOrder := (p1 < p3 and p3 < p5 and p5 < p7) and (p2 < p4 and p4 < p6 and p6 < p8) and (p5 < p2) and (p7 < p4)
    // Downtrend mirror
    g6_downOrder := (p1 > p3 and p3 > p5 and p5 > p7) and (p2 > p4 and p4 > p6 and p6 > p8) and (p5 > p2) and (p7 > p4)

    // Combined order check (any valid group)
    upOrderOK   = g1_upOrder or g2_upOrder or g3_upOrder or g4_upOrder or g5_upOrder or g6_upOrder
    downOrderOK = g1_downOrder or g2_downOrder or g3_downOrder or g4_downOrder or g5_downOrder or g6_downOrder

    // Điều kiện breakout mới
    off5 = math.max(0, bar_index - b5)
    off3 = math.max(0, bar_index - b3)
    off2 = math.max(0, bar_index - b2)
    off1 = math.max(0, bar_index - b1)
    
    lo5 = low[off5]
    hi2 = high[off2]
    lo3 = low[off3]
    lo1 = low[off1]
    hi5 = high[off5]
    lo2 = low[off2]
    hi3 = high[off3]
    hi1 = high[off1]
    
    upBreakout   = (lo5 > hi2) 
    downBreakout = (hi5 < lo2) 

    // Mẫu hợp lệ với điều kiện breakout phù hợp
    // Uptrend pattern + UP breakout conditions
    lastEightUp   := upStruct   and upOrderOK   and touchRetest and isHighest8 and upBreakout
    // Downtrend pattern + DOWN breakout conditions
    lastEightDown := downStruct and downOrderOK and touchRetest and isLowest8  and downBreakout

    // Lưu pivots khi mẫu hợp lệ
    if (lastEightDown or lastEightUp)
        pivot5 := p5
        pivot6 := p6
        // Store pivot values for confirmation logic
        saved_p5 := p5
        saved_p7 := p7
        saved_p8 := p8

    lastEightBarIdx := b8
    p2_price        := p2

// ---- Sau khi đã có eightReady ----
isAfterEight = eightReady and (bar_index > nz(lastEightBarIdx))

var bool fireChochUp = false
var bool fireChochDn = false
var string matchedGroup = na  // Track which pattern group matched

if eightReady and not na(pivot6) and not na(pivot5)
    // ========== 3-CANDLE CHoCH CONFIRMATION (matching Python logic) ==========
    // Pre-CHoCH [2] → CHoCH Bar [1] → Confirmation [0]
    
    // CHoCH Bar conditions (nến [1] - previous bar)
    // CHoCH Up: low[1] > low[2] AND close[1] > high[2] AND close[1] > pivot6 AND close[1] < pivot2
    chochUpBar = (low[1] > low[2]) and (close[1] > high[2]) and 
                 (close[1] > pivot6) and (close[1] < p2_price)
    
    // CHoCH Down: high[1] < high[2] AND close[1] < low[2] AND close[1] < pivot6 AND close[1] > pivot2
    chochDownBar = (high[1] < high[2]) and (close[1] < low[2]) and 
                   (close[1] < pivot6) and (close[1] > p2_price)

    // Confirmation conditions - Basic (nến [0] - current bar)
    // CHoCH Up confirmed: close của confirmation > high của nến pre-CHoCH [2]
    confirmUpBasic = (close > high[2])
    
    // CHoCH Down confirmed: close của confirmation < low của nến pre-CHoCH [2]
    confirmDownBasic = (close < low[2])

    // Check nếu nến CHoCH (bar[1]) là pivot mới nhất → lấy pivot trước đó
    // để tránh fail điều kiện isAfterEight
    chochBarIsPivot = (bar_index - 1 == lastEightBarIdx)
    nineReady = pCount() >= 9
    var int effectiveEightBarIdx = na
    var bool effectiveLastEightUp = false
    var bool effectiveLastEightDown = false
    
    if chochBarIsPivot and nineReady
        // Nến CHoCH là pivot → lấy pivot trước đó (offset 1)
        [b9,_,_] = getPivotFromEnd(1)
        effectiveEightBarIdx := b9
        // Lấy giá trị lastEightUp/Down từ nến trước đó (bar[1])
        effectiveLastEightUp := lastEightUp[1]
        effectiveLastEightDown := lastEightDown[1]
    else
        // Nến CHoCH không là pivot → dùng lastEightBarIdx bình thường
        effectiveEightBarIdx := lastEightBarIdx
        effectiveLastEightUp := lastEightUp
        effectiveLastEightDown := lastEightDown
    
    // Recalculate isAfterEight với effectiveEightBarIdx
    isAfterEightSafe = eightReady and (bar_index > nz(effectiveEightBarIdx))

    // Match with pattern direction - sử dụng isAfterEightSafe và effective values
    baseUp   = isAfterEightSafe and effectiveLastEightDown and chochUpBar and confirmUpBasic
    baseDown = isAfterEightSafe and effectiveLastEightUp   and chochDownBar and confirmDownBasic

    // ========== PATTERN GROUP SPECIFIC CONDITIONS for Confirmation Candle ==========
    // Determine which group matched
    if lastEightUp
        if g1_upOrder
            matchedGroup := "G1"
        else if g2_upOrder
            matchedGroup := "G2"
        else if g3_upOrder
            matchedGroup := "G3"
        else if g4_upOrder
            matchedGroup := "G4"
        else if g5_upOrder
            matchedGroup := "G5"
        else if g6_upOrder
            matchedGroup := "G6"
        else
            matchedGroup := na
    else if lastEightDown
        if g1_downOrder
            matchedGroup := "G1"
        else if g2_downOrder
            matchedGroup := "G2"
        else if g3_downOrder
            matchedGroup := "G3"
        else if g4_downOrder
            matchedGroup := "G4"
        else if g5_downOrder
            matchedGroup := "G5"
        else if g6_downOrder
            matchedGroup := "G6"
        else
            matchedGroup := na

    // Get volumes at pivot bars
    vol8 = getVolumeFromEnd(0)
    vol7 = getVolumeFromEnd(1)
    vol6 = getVolumeFromEnd(2)
    vol5 = getVolumeFromEnd(3)
    vol4 = getVolumeFromEnd(4)
    vol_choch = volume[1]  // Volume of CHoCH candle (previous bar)

    // Apply pattern group conditions with volume
    confirmUp = false
    confirmDown = false
    
    if baseUp and not na(matchedGroup)
        // Downtrend → CHoCH Up
        priceCondition = false
        volumeCondition = false
        
        if matchedGroup == "G1"
            // G1: Close_CF <= HIGH_5
            priceCondition := close <= saved_p5
            
            // (Vol8 OR Vol6 OR Vol_CHoCH) là lớn nhất cụm 678
            max_678 = math.max(vol6, math.max(vol7, vol8))
            vol_678_ok = (vol8 == max_678) or (vol6 == max_678) or (vol_choch == max_678)
            
            // (Vol4 OR Vol6) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            vol_456_ok = (vol4 == max_456) or (vol6 == max_456)
            
            // (Vol8 OR Vol_CHoCH) là lớn nhất cụm 45678
            max_45678 = math.max(vol4, math.max(vol5, math.max(vol6, math.max(vol7, vol8))))
            vol_45678_ok = (vol8 == max_45678) or (vol_choch >= max_45678)
            
            volumeCondition := (vol_678_ok and vol_456_ok) or vol_45678_ok
            confirmUp := priceCondition and volumeCondition
            
        else if matchedGroup == "G2"
            // G2: Close_CF <= HIGH_7
            priceCondition := close <= saved_p7
            
            // Volume condition G2/G3:
            // (Vol4 OR Vol5 OR Vol_CHoCH) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            volumeCondition := (vol4 == max_456) or (vol5 == max_456) or (vol_choch >= max_456)
            confirmUp := priceCondition and volumeCondition
            
        else if matchedGroup == "G3"
            // G3: Close_CF <= HIGH_5
            priceCondition := close <= saved_p5
            
            // Volume condition G2/G3:
            // (Vol4 OR Vol5 OR Vol_CHoCH) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            volumeCondition := (vol4 == max_456) or (vol5 == max_456) or (vol_choch >= max_456)
            confirmUp := priceCondition and volumeCondition

        // Additional groups for Up confirmation (Downtrend -> CHoCH Up): G4', G5', G6'
        else if matchedGroup == "G4"
            // G4': priceCondition close_choch > p8
            priceCondition := close > saved_p8
            volumeCondition := true
            confirmUp := priceCondition and volumeCondition

        else if matchedGroup == "G5"
            // G5': priceCondition close_choch > p8
            priceCondition := close > saved_p8
            volumeCondition := true
            confirmUp := priceCondition and volumeCondition

        else if matchedGroup == "G6"
            // G6': order conditions already checked; no extra price rule specified
            priceCondition := true
            volumeCondition := true
            confirmUp := priceCondition and volumeCondition
    
    if baseDown and not na(matchedGroup)
        // Uptrend → CHoCH Down
        priceCondition = false
        volumeCondition = false
        
        if matchedGroup == "G1"
            // G1: Close_CF >= LOW_5
            priceCondition := close >= saved_p5
            
            // (Vol8 OR Vol6 OR Vol_CHoCH) là lớn nhất cụm 678
            max_678 = math.max(vol6, math.max(vol7, vol8))
            vol_678_ok = (vol8 == max_678) or (vol6 == max_678) or (vol_choch == max_678)
            
            // (Vol4 OR Vol6) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            vol_456_ok = (vol4 == max_456) or (vol6 == max_456)
            
            // (Vol8 OR Vol_CHoCH) là lớn nhất cụm 45678
            max_45678 = math.max(vol4, math.max(vol5, math.max(vol6, math.max(vol7, vol8))))
            vol_45678_ok = (vol8 == max_45678) or (vol_choch >= max_45678)
            
            volumeCondition := (vol_678_ok and vol_456_ok) or vol_45678_ok
            confirmDown := priceCondition and volumeCondition
            
        else if matchedGroup == "G2"
            // G2: Close_CF >= LOW_7
            priceCondition := close >= saved_p7
            
            // Volume condition G2/G3:
            // (Vol4 OR Vol5 OR Vol_CHoCH) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            volumeCondition := (vol4 == max_456) or (vol5 == max_456) or (vol_choch >= max_456)
            confirmDown := priceCondition and volumeCondition
            
        else if matchedGroup == "G3"
            // G3: Close_CF >= LOW_5
            priceCondition := close >= saved_p5
            
            // Volume condition G2/G3:
            // (Vol4 OR Vol5 OR Vol_CHoCH) là lớn nhất cụm 456
            max_456 = math.max(vol4, math.max(vol5, vol6))
            volumeCondition := (vol4 == max_456) or (vol5 == max_456) or (vol_choch >= max_456)
            confirmDown := priceCondition and volumeCondition

        // New groups for Down confirmation (Uptrend -> CHoCH Down)
        else if matchedGroup == "G4"
            // G4: requires 10 pivots (order already checked). Price condition: close_choch < p8
            priceCondition := close < saved_p8
            volumeCondition := true
            confirmDown := priceCondition and volumeCondition

        else if matchedGroup == "G5"
            // G5: requires 10 pivots. Price condition: close_choch < p8
            priceCondition := close < saved_p8
            volumeCondition := true
            confirmDown := priceCondition and volumeCondition

        else if matchedGroup == "G6"
            // G6: order conditions include p5 < p2 and p7 < p4; no extra price rule specified
            priceCondition := true
            volumeCondition := true
            confirmDown := priceCondition and volumeCondition

    // Fire signal với locking
    fireChochUp := (not chochLocked) and confirmUp
    fireChochDn := (not chochLocked) and confirmDown

    if fireChochUp or fireChochDn
        chochLocked := true
        // Store bar index for persistent label
        if fireChochUp
            chochUpBar := bar_index
        if fireChochDn
            chochDownBar := bar_index

// ========== Plot ==========
plotshape(fireChochUp,  title="CHoCH Up",   style=shape.labelup,   text="CH↑",
          color=color.new(color.teal, 0),   textcolor=color.white, location=location.belowbar, size=size.tiny)
plotshape(fireChochDn,  title="CHoCH Down", style=shape.labeldown, text="CH↓",
          color=color.new(color.orange, 0), textcolor=color.white, location=location.abovebar, size=size.tiny)

// ========== Alert Conditions ==========
alertcondition(fireChochUp, title="CHoCH Up Alert", message="CHoCH Up detected on {{ticker}} {{interval}}")
alertcondition(fireChochDn, title="CHoCH Down Alert", message="CHoCH Down detected on {{ticker}} {{interval}}")
alertcondition(fireChochUp or fireChochDn, title="CHoCH Alert (Any)", message="CHoCH detected on {{ticker}} {{interval}}")
