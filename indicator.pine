//@version=5
indicator("Pivot Waves + 8-Pattern + CHoCH (pure pivot ver.)", overlay=true, max_lines_count=500, max_labels_count=500)

// ========== Inputs ==========
left        = input.int(1,  "Pivot Left",  minval=1)
right       = input.int(1,  "Pivot Right", minval=1)
drawWaves   = input.bool(true, "V·∫Ω s√≥ng (n·ªëi line gi·ªØa c√°c pivot)")
useBodyBreak= input.bool(true, "CHoCH theo th√¢n n·∫øn (close)")
touchTicks  = input.int(2, "ƒê·ªô dung sai 'ch·∫°m' (s·ªë tick)", minval=0)
keepPivots  = input.int(200, "S·ªë pivot t·ªëi ƒëa l∆∞u", minval=20)
plotPvtMark = input.bool(true, "Hi·ªÉn th·ªã PH/PL")
plotEightLbl = input.bool(true, "Ghi nh√£n P1..P8 g·∫ßn nh·∫•t")
showTable   = input.bool(true, "B·∫£ng th√¥ng tin")

var bool chochLocked = false 

// ========== Detect pivots (thu·∫ßn ta.pivot*) ==========
ph   = ta.pivothigh(high, left, right)
pl   = ta.pivotlow(low,  left, right)
isPH = not na(ph)
isPL = not na(pl)

// bar pivot n·∫±m ·ªü n·∫øn gi·ªØa (bar_index - right)
newPivotBar   = (isPH or isPL) ? (bar_index - right) : na
newPivotPrice = isPH ? ph : isPL ? pl : na
newPivotHigh  = isPH

// ========== Storage ==========
var prices = array.new_float()
var bars   = array.new_int()
var highs  = array.new_bool()

storePivot(_bar, _price, _isHigh) =>
    array.push(bars,   _bar)
    array.push(prices, _price)
    array.push(highs,  _isHigh)
    while array.size(bars) > keepPivots
        array.shift(bars)
        array.shift(prices)
        array.shift(highs)

pCount() => array.size(prices)

getPivotFromEnd(idxFromEnd) =>
    sz = array.size(prices)
    [ array.get(bars,   sz-1-idxFromEnd),
      array.get(prices, sz-1-idxFromEnd),
      array.get(highs,  sz-1-idxFromEnd) ]

// Dung sai tick
tol = syminfo.mintick * touchTicks

// ========== State vars ==========
var int   lastPivotBar   = na
var float lastPivotPrice = na
var bool  lastEightUp    = false
var bool  lastEightDown  = false
var int   lastEightBarIdx = na
var float p2_price       = na
var bool  acceptedPH_event = false
var bool  acceptedPL_event = false

// ========== Khi c√≥ pivot m·ªõi ==========
acceptedPH_event := false
acceptedPL_event := false

if (isPH or isPL)
    // --- ch√®n pivot gi·∫£ n·∫øu 2 pivot li√™n ti·∫øp c√πng lo·∫°i (gi·ªØ nguy√™n c∆° ch·∫ø c·ªßa b·∫°n) ---
    if pCount() > 0
        [lastBar, lastPrice, lastHigh] = getPivotFromEnd(0)
        newHigh = isPH
        if lastHigh == newHigh
            gap = newPivotBar - lastBar - 1
            if gap > 0
                firstBarInGap = lastBar + 1
                lastBarInGap  = newPivotBar - 1
                offsetFirst   = bar_index - firstBarInGap
                offsetLast    = bar_index - lastBarInGap
                if offsetFirst >= 0 and offsetLast >= 0
                    float insertPrice = newHigh ? low[offsetFirst] : high[offsetFirst]
                    int   insertBar   = firstBarInGap
                    bool  insertHigh  = not newHigh
                    for i = offsetFirst to offsetLast
                        float candidate = newHigh ? low[i] : high[i]
                        if (newHigh and candidate < insertPrice) or (not newHigh and candidate > insertPrice)
                            insertPrice := candidate
                            insertBar   := bar_index - i
                    if insertBar > lastBar and insertBar < newPivotBar
                        storePivot(insertBar, insertPrice, insertHigh)
                        if drawWaves and not na(lastPivotBar)
                            line.new(lastPivotBar, lastPivotPrice, insertBar, insertPrice, color=color.new(color.blue, 0), width=2)
                        lastPivotBar   := insertBar
                        lastPivotPrice := insertPrice

    // L∆∞u pivot m·ªõi
    storePivot(newPivotBar, newPivotPrice, newPivotHigh)
    if drawWaves and not na(lastPivotBar)
        line.new(lastPivotBar, lastPivotPrice, newPivotBar, newPivotPrice, color=color.new(color.blue, 0), width=2)
    lastPivotBar   := newPivotBar
    lastPivotPrice := newPivotPrice

    // reset kh√≥a CHoCH khi ƒë√£ h√¨nh th√†nh pivot sau c·ª•m 8 tr∆∞·ªõc ƒë√≥
    if not na(lastEightBarIdx) and newPivotBar > lastEightBarIdx
        chochLocked := false

    acceptedPH_event := isPH
    acceptedPL_event := isPL

// ========== 8-Pattern ==========
var float pivot6 = na   // p6 (reference cho CHoCH)
var float pivot5 = na   // p5 (additional reference cho CHoCH)
eightReady = pCount() >= 8
if eightReady
    [b8,p8,h8] = getPivotFromEnd(0)
    [b7,p7,h7] = getPivotFromEnd(1)
    [b6,p6,h6] = getPivotFromEnd(2)
    [b5,p5,h5] = getPivotFromEnd(3)
    [b4,p4,h4] = getPivotFromEnd(4)
    [b3,p3,h3] = getPivotFromEnd(5)
    [b2,p2,h2] = getPivotFromEnd(6)
    [b1,p1,h1] = getPivotFromEnd(7)

    // c·∫•u tr√∫c xen k·∫Ω 8 pivot
    upStruct   = (not h1) and h2 and (not h3) and h4 and (not h5) and h6 and (not h7) and h8
    downStruct = h1 and (not h2) and h3 and (not h4) and h5 and (not h6) and h7 and (not h8)

    // Retest P7 ‚Üî P4 (thay v√¨ P5 ‚Üî P2)
    off7 = math.max(0, bar_index - b7)
    off4 = math.max(0, bar_index - b4)
    hi7 = high[off7]
    lo7 = low[off7]
    hi4 = high[off4]
    lo4 = low[off4]
    touchRetest = (upStruct and (lo7 < hi4)) or (downStruct and (hi7 > lo4))

    // P8 l√† c·ª±c tr·ªã trong c·ª•m 1‚Äì8
    highsArr  = array.from(p1, p2, p3, p4, p5, p6, p7, p8)
    lowsArr   = array.from(p1, p2, p3, p4, p5, p6, p7, p8)
    isHighest8 = p8 == array.max(highsArr)
    isLowest8  = p8 == array.min(lowsArr)

    // R√†ng bu·ªôc th·ª© t·ª± 8-pivot
    upOrderOK   = (p2 < p4 and p4 < p6 and p6 < p8) and (p1 < p3 and p3 < p5 and p5 < p7)
    downOrderOK = (p1 > p3 and p3 > p5 and p5 > p7) and (p2 > p4 and p4 > p6 and p6 > p8)

    // ƒêi·ªÅu ki·ªán breakout m·ªõi
    off5 = math.max(0, bar_index - b5)
    off3 = math.max(0, bar_index - b3)
    off2 = math.max(0, bar_index - b2)
    off1 = math.max(0, bar_index - b1)
    
    lo5 = low[off5]
    hi2 = high[off2]
    lo3 = low[off3]
    lo1 = low[off1]
    hi5 = high[off5]
    lo2 = low[off2]
    hi3 = high[off3]
    hi1 = high[off1]
    
    upBreakout   = (lo5 > hi2) and (lo3 > lo1)
    downBreakout = (hi5 < lo2) and (hi3 < hi1)

    // M·∫´u h·ª£p l·ªá v·ªõi ƒëi·ªÅu ki·ªán breakout ph√π h·ª£p
    // Uptrend pattern + UP breakout conditions
    lastEightUp   := upStruct   and upOrderOK   and touchRetest and isHighest8 and upBreakout
    // Downtrend pattern + DOWN breakout conditions
    lastEightDown := downStruct and downOrderOK and touchRetest and isLowest8  and downBreakout

    // L∆∞u p5 v√† p6 khi m·∫´u h·ª£p l·ªá
    if (lastEightDown or lastEightUp)
        pivot5 := p5
        pivot6 := p6

    lastEightBarIdx := b8
    p2_price        := p2

// ---- Sau khi ƒë√£ c√≥ eightReady ----
isAfterEight = eightReady and (bar_index > nz(lastEightBarIdx))

var bool fireChochUp = false
var bool fireChochDn = false

if eightReady and not na(pivot6) and not na(pivot5)
    // ƒêi·ªÅu ki·ªán CHoCH c≈© (n·∫øn-k·ªÅ) ‚Äî gi·ªØ nguy√™n
    chochUpBar_old   = (low > low[1])   and (close > high[1])
    chochDownBar_old = (high < high[1]) and (close < low[1])

    // B·ªî SUNG logic m·ªõi v·ªõi pivot5:
    // CHoCH Up: close > pivot6 AND close < pivot5 (n·∫±m gi·ªØa pivot6 v√† pivot5)
    // CHoCH Down: close < pivot6 AND close > pivot5 (n·∫±m gi·ªØa pivot5 v√† pivot6)
    condUp   = lastEightDown and (close > (pivot6 + tol)) and (close < (pivot5 - tol))
    condDown = lastEightUp   and (close < (pivot6 - tol)) and (close > (pivot5 + tol))

    baseUp   = isAfterEight and chochUpBar_old   and condUp
    baseDown = isAfterEight and chochDownBar_old and condDown

    fireChochUp := (not chochLocked) and baseUp
    fireChochDn := (not chochLocked) and baseDown

    if fireChochUp or fireChochDn
        chochLocked := true

// ========== Plot ==========
plotshape(fireChochUp,  title="CHoCH Up",   style=shape.labelup,   text="CH‚Üë",
          color=color.new(color.teal, 0),   textcolor=color.white, location=location.belowbar, size=size.tiny)
plotshape(fireChochDn,  title="CHoCH Down", style=shape.labeldown, text="CH‚Üì",
          color=color.new(color.orange, 0), textcolor=color.white, location=location.abovebar, size=size.tiny)

// ========== Labels P1-P8 ==========
if plotEightLbl and eightReady
    [b8_,p8_,h8_] = getPivotFromEnd(0)
    [b7_,p7_,h7_] = getPivotFromEnd(1)
    [b6_,p6_,h6_] = getPivotFromEnd(2)
    [b5_,p5_,h5_] = getPivotFromEnd(3)
    [b4_,p4_,h4_] = getPivotFromEnd(4)
    [b3_,p3_,h3_] = getPivotFromEnd(5)
    [b2_,p2_,h2_] = getPivotFromEnd(6)
    [b1_,p1_,h1_] = getPivotFromEnd(7)
    
    // Hi·ªÉn th·ªã labels cho 8 pivot g·∫ßn nh·∫•t
    if barstate.islast
        label.new(b1_, p1_, "P1", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
        label.new(b2_, p2_, "P2", style=label.style_label_up,   color=color.red,  textcolor=color.white, size=size.small)
        label.new(b3_, p3_, "P3", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
        label.new(b4_, p4_, "P4", style=label.style_label_up,   color=color.red,  textcolor=color.white, size=size.small)
        label.new(b5_, p5_, "P5", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
        label.new(b6_, p6_, "P6", style=label.style_label_up,   color=color.red,  textcolor=color.white, size=size.small)
        label.new(b7_, p7_, "P7", style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
        label.new(b8_, p8_, "P8", style=label.style_label_up,   color=color.red,  textcolor=color.white, size=size.small)

// ========== B·∫£ng th√¥ng tin ==========
if showTable and barstate.islast
    var table infoTable = table.new(position.top_right, 2, 11, bgcolor=color.white, border_width=1)
    table.cell(infoTable, 0, 0, "8-Pattern Status", text_color=color.black, bgcolor=color.gray)
    table.cell(infoTable, 1, 0, "", text_color=color.black)
    
    if eightReady
        table.cell(infoTable, 0, 1, "Pattern", text_color=color.black)
        patternStatus = lastEightUp ? "‚úì Uptrend" : lastEightDown ? "‚úì Downtrend" : "‚ùå Invalid"
        patternColor = lastEightUp ? color.green : lastEightDown ? color.red : color.gray
        table.cell(infoTable, 1, 1, patternStatus, text_color=patternColor)
        
        table.cell(infoTable, 0, 2, "Pivot Count", text_color=color.black)
        table.cell(infoTable, 1, 2, str.tostring(pCount()), text_color=color.black)
        
        table.cell(infoTable, 0, 3, "Reference P6", text_color=color.black)
        table.cell(infoTable, 1, 3, not na(pivot6) ? str.tostring(pivot6, "#.####") : "N/A", text_color=color.black)
        
        table.cell(infoTable, 0, 4, "Reference P5", text_color=color.black)
        table.cell(infoTable, 1, 4, not na(pivot5) ? str.tostring(pivot5, "#.####") : "N/A", text_color=color.black)
        
        table.cell(infoTable, 0, 5, "CHoCH Locked", text_color=color.black)
        lockStatus = chochLocked ? "üîí Yes" : "üîì No"
        lockColor = chochLocked ? color.red : color.green
        table.cell(infoTable, 1, 5, lockStatus, text_color=lockColor)
    else
        table.cell(infoTable, 0, 1, "Status", text_color=color.black)
        table.cell(infoTable, 1, 1, "Need " + str.tostring(8 - pCount()) + " more pivots", text_color=color.orange)
